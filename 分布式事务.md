分布式事务解决方案 https://www.yisu.com/zixun/282182.html
1. 两阶段提交（2PC）
   
   第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
   
   第二阶段：事务协调器要求每个数据库提交数据。
   ![image](https://github.com/licker-cheng/java-Interview-book/assets/31842337/08f4c9de-5474-4092-bb62-a314f8a8e9de)


2. 补偿事务（TCC）
   
   TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

   Try 阶段主要是对业务系统做检测及资源预留

   Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。

   Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
   
   
3. 本地消息表（异步确保）

  本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。
   ![image](https://github.com/licker-cheng/java-Interview-book/assets/31842337/e7959c79-7223-47c1-a23a-6d812e6ea46c)

基本思路：

   a.消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
   
   b.消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。
   
   c.生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

